[{"title":"理解 Flutter 应用和部件的生命周期","url":"/2019/07/28/understand-flutter-lifecycle/","content":"\n## 前言\n\n在 Flutter 里面部件以及应用本身都有自己的生命周期，本文分别说明它们的生命周期\n\n## 部件\n\n在 Flutter 里面有两种部件 StatefulWidget 和 StatelessWidget，它们的生命周期分别是\n\n### StatelessWidget\n\n无状态部件的生命周期很简单，首先执行构造函数然后就执行 build 方法了\n\n```\nConstructor Function\n\nbuild()\n```\n\n### StatefulWidget\n\n有状态部件的生命周期会复杂一些，因为是多了状态变化。首先是构造函数，然后会初始化 State 在执行 build 方法，如果执行了 setState 方法，就要检查部件是否更新，在执行 build，最后部件销毁的时候执行 dispose 方法\n\n```\nConstructor Function\n\ninitState()\n\nbuild()\n\nsetState()\n\ndidUpdateWidget()\n\nbuild()\n\ndispose()\n```\n\n## 应用\n\nFlutter 应用本身也有自己的生命周期，要观察到这些状态的变化需要让一个有状态部件混入 `WidgetsBindingObserver`，然后在 `initState` 方法中创建一个观察者，当然部件销毁的时候需要把创建的观察者实现清除\n\n- inactive 应用处于非活动状态，并且未接收用户输入\n\n- paused 应用当前对用户不可见，不响应用户输入，并在后台运行\n\n- resumed 应用可见并响应用户输入\n\n- suspending 应用退出了\n\n代码\n\n```\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Lifecycle',\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> with WidgetsBindingObserver {\n  @override\n  void initState() {\n    WidgetsBinding.instance.addObserver(this);\n    super.initState();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n\tprint(state);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold();\n  }\n}\n```\n\n可以看到在 Flutter 应用里面这些生命周期还是挺简单易懂的\n","tags":["Flutter"],"categories":["Flutter"]},{"title":"对于 Workbox Strategies几种策略的解释","url":"/2019/07/27/about-workbox-strategies/","content":"\n要将自己的网站支持 PWA，需要注册一个 serviceWorker 到浏览器中，通常使用 Google 的 [Workbox](https://developers.google.com/web/tools/workbox/) 工具，Workbox 可以在浏览器请求资源的时候提供了几种不同的策略对请求响应，本文对几种策略进行说明。\n\n## StaleWhileRevalidate\n\nStaleWhileRevalidate 模式允许您使用缓存的响应尽快响应请求，如果未缓存，则返回到网络请求，然后，用网络请求更新缓存。\n\n![StaleWhileRevalidate](https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/stale-while-revalidate.png)\n\n```js\nworkbox.routing.registerRoute(\n  /\\.(?:js|css)$/,\n  new workbox.strategies.StaleWhileRevalidate({\n    cacheName: 'static'\n  })\n)\n```\n\n## CacheFirst\n\n如果缓存中存在响应，则将使用缓存的响应来完成请求，并且根本不会使用网络。 如果没有缓存的响应，则将通过网络请求来满足请求，并且将缓存响应，以便直接从缓存提供下一个请求。\n\n![CacheFirst](https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/cache-first.png)\n\n```js\nworkbox.routing.registerRoute(\n  /\\.(?:js|css)$/,\n  new workbox.strategies.CacheFirst({\n    cacheName: 'static'\n  })\n)\n```\n\n## NetworkFirst\n\n对于频繁更新的请求，网络优先策略是理想的解决方案。 默认情况下，它将尝试从网络获取最新响应，如果请求成功，它会将响应放入缓存中。 如果网络无法返回响应，则将使用缓存的响应。\n\n![NetworkFirst](https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/network-first.png)\n\n```js\nworkbox.routing.registerRoute(\n  /\\.(?:js|css)$/,\n  new workbox.strategies.NetworkFirst({\n    cacheName: 'static'\n  })\n)\n```\n\n## NetworkOnly\n\n仅使用网络响应请求。\n\n![NetworkOnly](https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/network-only.png)\n\n```js\nworkbox.routing.registerRoute(\n  /\\.(?:js|css)$/,\n  new workbox.strategies.NetworkOnly({\n    cacheName: 'static'\n  })\n)\n```\n\n## CacheOnly\n\n仅使用缓存响应请求。不常见，但如果您有自己的预先缓存步骤，则可能很有用。\n\n![CacheOnly](https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/cache-only.png)\n\n```js\nworkbox.routing.registerRoute(\n  /\\.(?:js|css)$/,\n  new workbox.strategies.CacheOnly({\n    cacheName: 'static'\n  })\n)\n```\n\n## 参考\n\n[官方文档](https://developers.google.com/web/tools/workbox/modules/workbox-strategies)\n","tags":["PWA, Workbox"],"categories":["Web"]},{"title":"使用 Travis CI 部署 Hugo 博客到 Github Pages","url":"/2019/07/26/hugo-travis-github-page/","content":"\n原本使用的是 Netlify 去部署博客的，域名解析也是通过 Netlify 的 DNS 服务器，但是发现博客在别人的电脑上打不开...发现是域名解析的问题，所以就把博客放到 Github Pages 上了，但是这样就失去了 Netlify 提供的自动构建和部署的能力，需要自己去配置 Travis CI 实现自动部署了。\n\n## 预先要求\n\n- 本地安装了 [Hugo](https://gohugo.io)\n- 一个 [Github](https://github.com/) 账号\n- 使用 Github 账号登录 [Travis](https://travis-ci.org)\n\n## 创建博客\n\n使用 Hugo 命令行工具新建自己的博客，将代码推送到自己的 Github 仓库\n\n```sh\nhugo new site my-blog\n...\ngit push\n```\n\n## 新建一个 Github Personal access token\n\n在 https://github.com/settings/tokens 新建一个 Personal access token 用来发布博客到 Github Pages 时进行验证，复制生成的 token，不要刷新或离开当前页面，否则 token 就看不见了，只能重新生成\n\n![token](/images/github-token.jpg)\n\n登录到 [Travis CI](https://travis-ci.org) 对项目进行关联 https://travis-ci.org/account/repositories\n\n完成后进入设置界面 `https://travis-ci.org/your-gihub-user-name/your-gihub-repo/settings`\n\n在 Environment Variables 填写 GITHUB_TOKEN 变量，点击 Add 按钮，这样你的环境变量就添加完成了\n\n## 配置 .travis.yml\n\n因为 Hugo 是用 GO 语言写的，所以要配置 GO 编译环境，在 before_script 里删除了 public 文件夹，如果有自定义域名，将自定义域名输出到构建出来的 CNAME 文件里面去，记得添加 DNS 解析记录到 Gihub 去 [参考](https://help.github.com/cn/articles/using-a-custom-domain-with-github-pages)\n\n```json\nlanguage: go\n\ndist: trusty\n\nsudo: false\n\nenv:\n  - HUGO_VERSION=0.56.0\n\ninstall: true\n\nbefore_script:\n  - wget https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_${HUGO_VERSION}_Linux-64bit.deb\n  - sudo dpkg -i hugo_${HUGO_VERSION}_Linux-64bit.deb\n  - rm -rf public || exit 0\n\nscript:\n  - hugo -v --gc --minify\n  - echo 'your-custom-domain.com' > public/CNAME\n\ndeploy:\n  provider: pages\n  local-dir: public\n  skip-cleanup: true\n  github-token: $GITHUB_TOKEN\n  keep-history: true\n  on:\n    branch: master\n\nbranches:\n  only:\n  - master\n\n```\n\n## 提交触发构建\n\n最后新建一篇文章，push 到 Github 仓库，触发 Travis 构建就可以了，以后博客进行更新后就可以自动构建发布了。\n\n```sh\nhugo new posts/my-first-post.md\n```\n","tags":["Hugo"],"categories":["CI"]},{"title":"对于 manifest.json 设置的解释","url":"/2019/07/25/about-manifest/","content":"\n网站要支持 PWA，需要一个 `manifest.json` 文件，W3C Web App Manifest 的草案上定义了以下的字段，解释一下每个字段是什么意思。\n\n```js\ndictionary WebAppManifest {\n   TextDirectionType dir = \"auto\";\n   DOMString lang;\n   USVString name;\n   USVString short_name;\n   USVString description;\n   sequence<ImageResource> icons;\n   sequence<ImageResource> screenshots;\n   sequence<USVString> categories;\n   DOMString iarc_rating_id;\n   USVString start_url;\n   DisplayModeType display = \"browser\";\n   OrientationLockType orientation;\n   USVString theme_color;\n   USVString background_color;\n   USVString scope;\n   ServiceWorkerRegistrationObject serviceworker;\n   sequence<ExternalApplicationResource> related_applications;\n   boolean prefer_related_applications = \"false\";\n};\n\ndictionary ImageResource {\n  required USVString src;\n  DOMString sizes;\n  USVString type;\n  USVString purpose;\n  USVString platform;\n};\n\ndictionary ServiceWorkerRegistrationObject {\n  required USVString src;\n  USVString scope;\n  WorkerType type = \"classic\";\n  ServiceWorkerUpdateViaCache update_via_cache = \"imports\";\n};\n\ndictionary ExternalApplicationResource {\n  required USVString platform;\n  USVString url;\n  DOMString id;\n  USVString min_version;\n  sequence<Fingerprint> fingerprints;\n};\n```\n\n**dir** 指定了 manifest 中具有方向性的成员的基本方向，可以设置 `ltr` 左至右, `rtl` 右至左, `auto` 没有明确方向。\n\n**lang** 指定 manifest 中具有方向性成员的值的主要语言（因为知道语言也可以帮助方向性）。\n\n**name** 表示应用的名称。\n\n**short_name** 表示 Web 应用程序名称的简短版本，用于没有足够空间来显示 Web 应用程序的全名的地方。\n\n**description** 描述 Web 应用程序的目的。\n\n**scope** 表示 Web 应用程序导航范围。\n\n**icons** icons 是 ImageResources 的数组，可以在各种情况下充当 Web 应用程序的图标表示。例如，它们可用于在其他应用程序列表中表示 Web 应用程序，或者将 Web 应用程序与 OS 的任务切换器和/或系统首选项集成。\n\n```json\n{\n  \"icons\": [\n    {\n      \"src\": \"icon/lowres.webp\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"icon/lowres\",\n      \"sizes\": \"48x48\"\n    },\n    {\n      \"src\": \"icon/hd_hi.ico\",\n      \"sizes\": \"72x72 96x96 128x128 256x256\"\n    },\n    {\n      \"src\": \"icon/hd_hi.svg\",\n      \"sizes\": \"257x257\"\n    }\n  ]\n}\n```\n\n**display** 其值是 DisplayModeType 值之一，表示开发人员对 Web 应用程序的首选显示模式。可以设置\n\n- \"fullscreen\" 占用整个可用的显示区域；\n- \"standalone\" 使其外观和感觉就像一个独立的本机应用程序；\n- \"minimal-ui\" 类似于 standalone 模式，但为最终用户提供了一些方法来访问用于控制导航的最小 UI 元素集（即，后退，前进，重新加载以及可能以某种方式查看文档的地址）；\n- \"browser\" 使用特定于平台的约定打开 Web 应用程序，以在用户代理中打开超链接（例如，在浏览器选项卡或新窗口中）；\n\n**orientation** Web 应用程序的所有顶级浏览上下文的默认方向。\n\n**start_url** 表示起始 URL 的字符串，该 URL 是用户启动 Web 应用程序时开发人员更喜欢用户代理加载的 URL（例如，当用户从设备的应用程序菜单中单击 Web 应用程序的图标时或主屏幕）。\n\n**serviceworker** 表示应用中 serviceWorker 的信息。\n\n```json\n\"serviceworker\": {\n  \"src\": \"sw.js\",\n  \"scope\": \"/foo\",\n  \"update_via_cache\": \"none\"\n}\n```\n\n**theme_color** 应用程序上下文的默认主题颜色。\n\n**related_applications** 是底层应用程序平台可访问的应用程序。\n\n**prefer_related_applications** 表示相关应用程序是否应优先于当前的 Web 应用程序。\n\n**background_color** Web 应用程序的预期背景颜色。\n\n**categories** Web 应用程序所属的预期应用程序类别。\n\n**screenshots** 一个 ImageResources 数组，表示常见使用场景中的 Web 应用程序的截图。\n\n**iarc_rating_id** 用于确定 Web 应用程序适合的年龄。\n\n一个完整的示例\n\n```json\n{\n  \"lang\": \"en\",\n  \"dir\": \"ltr\",\n  \"name\": \"Super Racer 3000\",\n  \"description\": \"The ultimate futuristic racing game from the future!\",\n  \"short_name\": \"Racer3K\",\n  \"icons\": [\n    {\n      \"src\": \"icon/lowres.webp\",\n      \"sizes\": \"64x64\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"icon/lowres.png\",\n      \"sizes\": \"64x64\"\n    },\n    {\n      \"src\": \"icon/hd_hi\",\n      \"sizes\": \"128x128\"\n    }\n  ],\n  \"scope\": \"/racer/\",\n  \"start_url\": \"/racer/start.html\",\n  \"display\": \"fullscreen\",\n  \"orientation\": \"landscape\",\n  \"theme_color\": \"aliceblue\",\n  \"background_color\": \"red\",\n  \"serviceworker\": {\n    \"src\": \"sw.js\",\n    \"scope\": \"/racer/\",\n    \"update_via_cache\": \"none\"\n  },\n  \"screenshots\": [\n    {\n      \"src\": \"screenshots/in-game-1x.jpg\",\n      \"sizes\": \"640x480\",\n      \"type\": \"image/jpeg\"\n    },\n    {\n      \"src\": \"screenshots/in-game-2x.jpg\",\n      \"sizes\": \"1280x920\",\n      \"type\": \"image/jpeg\"\n    }\n  ]\n}\n```\n\n要在页面是使用的话直接用 <link> 标签引用即可。\n\n```html\n<link rel=\"manifest\" href=\"/manifest.json\" />\n```\n\n这样浏览器就可以安装你的 Web 应用了。\n","tags":["PWA"],"categories":["WEB"]},{"title":"让 Hugo 博客支持 PWA","url":"/2019/07/24/add-pwa-support-to-hugo/","content":"\n让用 Hugo 搭建的博客支持 PWA 很简单，只需 2 个步骤即可：\n\n## 1. 添加一个 manifest.json 文件\n\n使用 https://app-manifest.firebaseapp.com 来生成博客的 manifest.json 文件，然后将生成出来的文件和图片放到博客的 static 目录，然后在 layout/index.html 的 <head> 标签内引用这个文件\n\n```html\n<head>\n  ...\n  <link rel=\"manifest\" href=\"/manifest.json\" />\n  ...\n</head>\n```\n\n这样你的博客就可以安装到桌面了\n\n## 2. 使用 Workbox 工具注册 ServiceWorker\n\n在 static 新建一个 `sw.js` 文件，在文件添加以下内容用来为网络请求添加缓存；主要是缓存静态资源 js，css，图片以及字体等文件，\n详细文档可以查看 [Workbox 文档](https://developers.google.cn/web/tools/workbox)\n\n```js\nimportScripts('https://cdn.jsdelivr.net/npm/workbox-cdn/workbox/workbox-sw.js')\n\nif (workbox) {\n  console.log(`Yay! Workbox is loaded 🎉`)\n\n  workbox.routing.registerRoute(\n    /\\.(?:js|css)$/,\n    new workbox.strategies.StaleWhileRevalidate({\n      cacheName: 'static-resources'\n    })\n  )\n\n  workbox.routing.registerRoute(\n    /\\.(?:png|jpg|jpeg|svg|gif)$/,\n    new workbox.strategies.CacheFirst({\n      cacheName: 'image-cache',\n      plugins: [\n        new workbox.expiration.Plugin({\n          maxEntries: 20,\n          maxAgeSeconds: 7 * 24 * 60 * 60\n        })\n      ]\n    })\n  )\n\n  workbox.routing.registerRoute(\n    /^https:\\/\\/fonts\\.googleapis\\.com/,\n    new workbox.strategies.StaleWhileRevalidate({\n      cacheName: 'google-fonts-stylesheets'\n    })\n  )\n\n  workbox.routing.registerRoute(\n    /^https:\\/\\/fonts\\.gstatic\\.com/,\n    new workbox.strategies.CacheFirst({\n      cacheName: 'google-fonts-webfonts',\n      plugins: [\n        new workbox.cacheableResponse.Plugin({\n          statuses: [0, 200]\n        }),\n        new workbox.expiration.Plugin({\n          maxAgeSeconds: 60 * 60 * 24 * 365,\n          maxEntries: 30\n        })\n      ]\n    })\n  )\n} else {\n  console.log(`Boo! Workbox didn't load 😬`)\n}\n```\n\n基本完成了，可以用 Chrome 的 Audits 的工具跑了一下分，看看还有什么地方要修改的。\n","tags":["PWA"],"categories":["WEB"]},{"title":"了解 <link> 标签上 rel=prexxx 的作用","url":"/2019/07/22/understand-link-prexxx/","content":"\n在 HTML 中 <link> 标签指定了当前文档与外部资源之间的关系\n本文说明 <link> 标签的 rel 属性分别设置 dns-prefetch，preconnect，prefetch，preload，prerender 的时候有说明作用\n\ndns-prefetch：向浏览器提示需要资源，允许浏览器在用户单击链接之前进行 DNS 查找和协议握手\n\npreconnect：向浏览器提供提示，建议它提前打开与链接网站的连接，而不泄露任何私人信息或下载任何内容，以便在遵循链接时可以更快地获取链接的内容\n\nprefetch：建议浏览器提前获取链接资源，因为它可能是用户请求的。 从 Firefox 44 开始，将考虑 crossorigin 属性的值，从而可以进行匿名预取\n\npreload：告诉浏览器下载资源，因为稍后在当前导航期间将需要此资源\n\nprerender：建议浏览器提前获取链接资源，并且它还在屏幕外渲染预取内容，以便在需要时可以快速呈现给用户\n\n## 参考\n\n[link_types](https://devdocs.io/html/link_types)\n\n[preconnect-vs-dns-prefetch-resource-hints](https://stackoverflow.com/questions/47273743/preconnect-vs-dns-prefetch-resource-hints)\n","tags":["HTML"],"categories":["Web"]},{"title":"浏览器请求耗时阶段解释","url":"/2019/07/18/request-timimg/","content":"\n## 一个请求耗时阶段解释\n\n**Queueing** 浏览器会在以下情况时将请求加入队列，有优先级更高的请求；当请求协议是 HTTP/1.0 和 HTTP/1.1 时，同一域名下已经有 6 个 TCP 链接；浏览器在分配磁盘缓存\n\n**Stalled** 由于排队中描述的任何原因，请求可能会停止\n\n**DNS Lookup** 浏览器正在解析请求的 IP 地址\n\n**Proxy negotiation** 浏览器与代理服务器协商请求\n\n**Request sent** 请求已经发出\n\n**ServiceWorker Preparation** 浏览器启动 service worker\n\n**Request to ServiceWorker** 请求已经向 service worker 发出\n\n**Waiting (TTFB)** 浏览器等待第一个字节返回，此时间包括 1 次往返延迟和服务器准备响应所用的时间。\n\n**Content Download**. 浏览器接收响应\n\n**Receiving Push**. 浏览器收到通过 HTTP/2 Server Push 的响应\n\n**Reading Push**. 浏览器正在读取先前收到的本地数据\n\n## Timing breakdown phases explained\n\nHere's more information about each of the phases you may see in the Timing tab:\n\n**Queueing**. The browser queues requests when:\n\n- There are higher priority requests.\n- There are already six TCP connections open for this origin, which is the limit. Applies to HTTP/1.0 and HTTP/1.1 only.\n- The browser is briefly allocating space in the disk cache\n\n**Stalled**. The request could be stalled for any of the reasons described in**Queueing**.\n\n**DNS Lookup**. The browser is resolving the request's IP address.\n\n**Proxy negotiation**. The browser is negotiating the request with a[proxy server](https://en.wikipedia.org/wiki/Proxy_server).\n\n**Request sent**. The request is being sent.\n\n**ServiceWorker Preparation**. The browser is starting up the service worker.\n\n**Request to ServiceWorker**. The request is being sent to the service worker.\n\n**Waiting (TTFB)**. The browser is waiting for the first byte of a response. TTFB stands for Time To First Byte. This timing includes 1 round trip of latency and the time the server took to prepare the response.\n\n**Content Download**. The browser is receiving the response.\n\n**Receiving Push**. The browser is receiving data for this response via HTTP/2 Server Push.\n\n**Reading Push**. The browser is reading the local data previously received.\n","tags":["Browser"],"categories":["Web"]},{"title":"Dart 语言中的 final 与 const 的区别","url":"/2019/07/16/dart-final-vs-const/","content":"\n在 Dart 中有 `final` 和 `const` 两个关键字，貌似都是表示常量的，但是它们还是有区别的\n\nfinal 变量的值只能被设置一次； const 变量在编译时就已经固定 (const 变量是隐式 final 的类型.) 最高级 final 变量或类变量在第一次使用时被初始化。\n\n[官方文档](https://dart.dev/guides/language/language-tour#final-and-const)\n","tags":["Dart"],"categories":["Dart"]},{"title":"关于 Apple 的 Code Signing","url":"/2019/07/15/code-signing/","content":"\n想要把 Flutter 写的应用运行在 iPhone 上，必须要进行 Code Signing\n\n[官方文档](https://developer.apple.com/support/code-signing/)\n\n## Code Signing\n\nCode signing your app assures users that it is from a known source and the app hasn’t been modified since it was last signed. Before your app can integrate app services, be installed on a device, or be submitted to the App Store, it must be signed with a[certificate](https://developer.apple.com/support/certificates/)issued by Apple. For more information on how to request certificates and code sign your apps, review[Xcode Help](https://help.apple.com/xcode/mac/current/).\n\n## 代码签名\n\n代码签名您的应用程序会向用户保证它来自已知来源，并且该应用程序自上次签名后未被修改。 在您的应用程序可以集成应用程序服务，安装在设备上或提交到 App Store 之前，必须使用 Apple 颁发的证书进行签名。\n","tags":["iOS"],"categories":["Flutter"]}]